/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package multiproject.server

import kotlinx.coroutines.*
import kotlinx.coroutines.channels.actor
import kotlinx.coroutines.channels.produce
import multiproject.lib.dto.request.PathDto
import multiproject.lib.dto.request.RequestDirection
import multiproject.lib.dto.response.ResponseCode
import multiproject.lib.dto.response.ResponseDto
import multiproject.lib.request.Request
import multiproject.lib.udp.interfaces.OnReceive
import multiproject.lib.udp.server.ServerUdpChannel
import multiproject.lib.udp.server.runServer
import multiproject.lib.utils.LogLevel
import multiproject.lib.utils.Logger
import multiproject.lib.utils.SocketAddressInterpreter
import multiproject.server.collection.Collection
import multiproject.server.collection.item.EntityBuilder
import multiproject.server.command.*
import multiproject.server.command.system.SystemDumpCommand
import multiproject.server.command.system.SystemLoadCommand
import multiproject.server.command.user.AuthCommand
import multiproject.server.command.user.GetByTokenCommand
import multiproject.server.command.user.LongCommand
import multiproject.server.command.user.SignupCommand
import multiproject.server.database.DatabaseManager
import multiproject.server.dump.DumpManager
import multiproject.server.dump.PostgresqlDumpManager
import multiproject.server.middlewares.auth.AuthMiddleware
import multiproject.server.middlewares.auth.BuildAuthorMiddleware
import multiproject.server.modules.flat.Flat
import multiproject.server.modules.flat.FlatBuilder
import multiproject.server.modules.flat.FlatCollection
import org.koin.core.context.GlobalContext.startKoin
import org.koin.core.qualifier.named
import org.koin.dsl.module
import java.util.*
import kotlin.coroutines.CoroutineContext

class App {
    init {
        val logger = Logger(LogLevel.DEBUG)
        val collection = FlatCollection(mutableListOf(), FlatBuilder())
        val module = module {
            single<Collection<Flat>>(named("collection")) {
                collection
            }
            single<DumpManager<Flat>>(named("dumpManager")) {
                PostgresqlDumpManager(FlatBuilder())
            }
            single<EntityBuilder<Flat>>(named("builder")) {
                FlatBuilder()
            }
            single<DatabaseManager>(named("dbManager")) {
                DatabaseManager()
            }
            single<Logger>(named("logger")) {
                logger
            }
            single<ServerUdpChannel>(named("server")) {
                runServer {
                    this.logger = logger
                    applyRouter {
                        addController {
                            name = "collection"
                            addMiddleware(AuthMiddleware)
                            addRoute {
                                name = "help"
                                command = HelpCommand(this@addController)
                            }
                            addRoute {
                                name = "info"
                                command = InfoCommand(this@addController)
                            }
                            addRoute {
                                name = "add"
                                command = AddCommand(this@addController)
                                addMiddleware(BuildAuthorMiddleware)
                            }
                            addRoute {
                                name = "show"
                                command = ShowCommand(this@addController)
                            }
                            addRoute {
                                name = "update"
                                command = UpdateCommand(this@addController)
                                addMiddleware(BuildAuthorMiddleware)
                            }
                            addRoute {
                                name = "remove_by_id"
                                command = RemoveByIdCommand(this@addController)
                            }
                            addRoute {
                                name = "load"
                                command = LoadCommand(this@addController)
                            }
                            addRoute {
                                name = "execute_script"
                                command = ExecuteScriptCommand(this@addController)
                            }
                            addRoute {
                                name = "remove_at"
                                command = RemoveAtCommand(this@addController)
                            }
                            addRoute {
                                name = "add_if_max"
                                command = AddIfMaxCommand(this@addController)
                                addMiddleware(BuildAuthorMiddleware)
                            }
                            addRoute {
                                name = "reorder"
                                command = ReorderCommand(this@addController)
                            }
                            addRoute {
                                name = "count_by_number_of_rooms"
                                command = CountByNumberOfRoomsCommand(this@addController)
                            }
                            addRoute {
                                name = "count_less_than_time_to_metro_by_transport"
                                command = CountLessThanTimeToMetroByTransportCommand(this@addController)
                            }
                            addRoute {
                                name = "filter_less_than_furnish"
                                command = FilterLessThanFurnish(this@addController)
                            }
                        }
                        addController {
                            name = "system"
                            needAuth = false
                            addRoute {
                                name = "_load"
                                command = SystemLoadCommand(this@addController)
                            }
                            addRoute {
                                name = "_dump"
                                command = SystemDumpCommand(this@addController)
                            }
                        }
                        addController {
                            name = "user"
                            addRoute {
                                name = "auth"
                                authorizationEndpoint = true
                                command = AuthCommand(this@addController)
                                needAuth = false
                            }
                            addRoute {
                                name = "long"
                                command = LongCommand(this@addController)
                                needAuth = false
                            }
                            addRoute {
                                name = "signup"
                                command = SignupCommand(this@addController)
                                needAuth = false
                            }
                            addRoute {
                                name = "get"
                                command = GetByTokenCommand(this@addController)
                                addMiddleware(AuthMiddleware)
                            }
                            addRoute {
                                name = "help"
                                command = HelpCommand(this@addController)
                                needAuth = false
                            }
                        }
                    }
                    receiveCallback = OnReceive {
                        address, request -> run {
                            if (request.isEmptyPath())
                                return@run

                            if (request.path.controller == "_system" && request.path.route == "sync") {
                                collection.loadDump()
                                return@run
                            }

                            val syncType = request.getSyncType()
                            val syncHelper = request.getSyncHelper()
                            if (syncType.sync) {
                                collection.pull(request.getSyncHelper().commits)
                                syncHelper.servers.forEach {
                                    this.emit(it!!, Request(PathDto("_system", "sync")))
                                }
                            }


                            val response = router.run(request)

                            request.apply {
                                this.response = response.dto ?: ResponseDto(ResponseCode.INTERNAL_SERVER_ERROR, "Resolver error")

                                this setDirection RequestDirection.FROM_SERVER
                                this setSender getChannelAddress()

                                this setSyncHelper (this.getSyncHelper().apply {
                                    if (syncType.sync)
                                        this.synchronizationEnded = true
                                    this.commits.addAll(response.commits)
                                })
                            }

                            emit(
                                SocketAddressInterpreter.interpret(address),
                                request
                            )
                        }
                    }
                    bindOn(
                        address = null
                    )
                }
            }
        }
        startKoin {
            modules(
                module
            )
        }
    }
}


class Collection(private val context: CoroutineContext) {
    val items: MutableList<Int> = mutableListOf()
    sealed class CollectionCommands {
        class AddItemCommand(val item: Int): CollectionCommands()

        class GetCollectionCommand(val result: CompletableDeferred<Pair<Int, List<Int>>> = CompletableDeferred()): CollectionCommands()

    }

    private val scope = CoroutineScope(context)

    @OptIn(ObsoleteCoroutinesApi::class)
    val commands = scope.actor<CollectionCommands>(capacity = 200) {
        for (command in this) {
            when(command) {
                is CollectionCommands.AddItemCommand -> items.add(command.item)
                is CollectionCommands.GetCollectionCommand -> command.result.complete(Pair(items.size, items.toList()))
            }
        }
    }

    fun addItem(item: Int) {
        commands.trySend(CollectionCommands.AddItemCommand(item))
    }

    suspend fun getCollection(): Pair<Int, List<Int>> {
        val get = CollectionCommands.GetCollectionCommand()
        commands.send(get)
        return get.result.await()
    }
}


abstract class Task(val taskName: String) { //aka Command
    abstract suspend fun run()
}

class SuperLongTask(taskName: String, val collection: multiproject.server.Collection): Task(taskName) {
    override suspend fun run() {
        delay(10000L)
        collection.addItem(1)
        println("Super long task: $taskName is completed!")
    }
}

class NormalLongTask(taskName: String, val collection: multiproject.server.Collection): Task(taskName) {
    override suspend fun run() {
        delay(5000L)
        collection.addItem(1)
        println("Normal long task: $taskName is completed!")
    }
}

class TaskRunner() { //aka Router
    private val scope: CoroutineScope = CoroutineScope(Dispatchers.IO)
    fun run(task: Task) {
        scope.launch { task.run() }
    }
}

fun getRandom(max: Int): Int {
    return Random().nextInt(max)
}

@OptIn(ExperimentalCoroutinesApi::class)
fun main(): Unit = runBlocking {
//    val server: ServerUdpChannel by inject(ServerUdpChannel::class.java, named("server"))
//    val collection: Collection<Flat> by inject(Collection::class.java, named("collection"))
//    App()
//    collection.loadDump()
//    server.bindToResolver()
//    server.run()
    val collection = Collection(Dispatchers.Default)
    withContext(Dispatchers.IO) {
        val channel = produce<Task> {
            var num = 0
            while (num < 100) {
                num++
                val task = getRandom(1)
                if (task == 1) {
                    send(SuperLongTask("$num", collection))
                } else {
                    send(NormalLongTask("$num", collection))
                }
                println(task)
            }
        }

        launch {
            val taskRunner = TaskRunner()
            var counter = 100
            while (true) {
                val tryToGet = channel.tryReceive()
//            println(tryToGet)
                if (tryToGet.isSuccess) {
                    val task = tryToGet.getOrNull()
                    println("We got! {$counter} ${task?.taskName}")
                    taskRunner.run(task!!)
                    counter--
                }

            }
        }

        println("we are launched!")

        delay(15000L)

        val collectionData = collection.getCollection()

        println(collectionData)
    }



}