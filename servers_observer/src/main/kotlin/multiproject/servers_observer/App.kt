/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package multiproject.servers_observer

import io.prometheus.client.CollectorRegistry
import io.prometheus.client.Histogram
import io.prometheus.client.Summary
import io.prometheus.client.exporter.HTTPServer
import kotlinx.coroutines.*
import multiproject.lib.udp.UdpConfig
import multiproject.lib.udp.interfaces.OnReceive
import multiproject.lib.udp.server.ServerUdpChannel
import multiproject.lib.udp.server.runServer
import multiproject.lib.utils.LogLevel
import multiproject.lib.utils.Logger
import org.koin.core.context.GlobalContext.startKoin
import org.koin.core.qualifier.named
import org.koin.dsl.module
import org.koin.java.KoinJavaComponent.inject
import java.net.InetSocketAddress


class App {
    val registry: CollectorRegistry = CollectorRegistry()
    init {
        val logger = Logger(LogLevel.DEBUG)
        val testMetrics = TestMetricDto(
            Summary.build().name("cache").help("Total elements.").labelNames("server").register(registry),
            Histogram.build().name("cache_histogram").help("Total elements").labelNames("server").register(registry),
        )
        val module = module {
            single<Logger>(named("logger")) {
                logger
            }
            single<TestMetricDto>(named("testMetrics")) {
                testMetrics
            }
            single<ServerUdpChannel>(named("server")) {
                runServer {
                    this.logger = logger
                    receiveCallback = OnReceive {
                        address, request -> withContext(Dispatchers.Default) {
                            if (request.isEmptyPath())
                                return@withContext

                            requestsChannel.send(Pair(address, request))
                        }
                    }
                    bindOn(
                        address = InetSocketAddress(UdpConfig.observerAddress, UdpConfig.observerPort)
                    )
                }
            }
        }
        startKoin {
            modules(
                module
            )
        }
    }
}

@OptIn(ExperimentalCoroutinesApi::class)
fun main(): Unit = runBlocking (
    CoroutineExceptionHandler {
        _, error -> run {
            println("Caught here!")
            val logger: Logger by inject(Logger::class.java, named("logger"))
            logger(LogLevel.FATAL, "Fatal error!", Exception(error))
        }
    }
) {
    val app = App()
    HTTPServer.HTTPMetricHandler(app.registry)
    val server: ServerUdpChannel by inject(ServerUdpChannel::class.java, named("server"))
    val testMetrics: TestMetricDto by inject(TestMetricDto::class.java, named("testMetrics"))
    HTTPServer.Builder()
        .withPort(9091)
        .withRegistry(app.registry)
        .build()

    withContext(Dispatchers.Default) {
        launch {
            server.run()
        }

        launch {
            while (true) {
                val tryToGet = server.requestsChannel.tryReceive()

                if (tryToGet.isSuccess) {
                    val item = tryToGet.getOrNull()!!
                    val msg = item.second.data.arguments
                    if (msg.containsKey("cache_dump")) {
                        testMetrics.elementsCounter.labels(item.first.toString()).observe(msg["cache_dump"]!!.toString().toDouble())
                    }
                }
            }
        }
    }
}